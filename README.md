# 花式搜索-八数码问题

八数码问题其实就是移动拼图。之前和对象一起去黄埔古港，有个固定的拼图，在一个3*3的方格里摆着8个不同都方片，我们可以通过移动方片让它变成一条完整都船。那时我研究了一下，很快就找到技巧，先对着拼图看了1分钟。然后突然用飞快的速度把拼图移动完毕，收获了来自女朋友仰慕的目光，收获颇大。

假如我们把那张图片，换成一个数字为1-9矩阵，9代表空格。我们的目标就是把一个乱七八糟的矩阵移动为一个顺序的矩阵。形如：

![](http://latex.codecogs.com/svg.latex?%5Cbegin%7Bmatrix%7D%0A2%20%26%203%20%26%204%20%5C%5C%0A1%20%26%205%20%5C%5C%0A7%20%26%206%20%26%208%0A%5Cend%7Bmatrix%7D%20%5Crightarrow%20%5Cbegin%7Bmatrix%7D%0A1%20%26%202%20%26%203%20%5C%5C%0A4%20%26%205%20%26%206%20%5C%5C%0A7%20%26%208%20%26%0A%5Cend%7Bmatrix%7D)

八数码问题想要找到解十分简单，毕竟能够按照很固定的规律就能把方片摆好。但是，想要找到最快的方法解决并没有那么容易。这里，我参照**八数码的八重境界**练习了好几种八数码问题的解法，对搜索理解一下子就深厚了很多。这里均采用OJ的方式来评判正确性，POJ1077/HDU1043。由于打表法太简单了，所以我采取了每次搜索的方法。

这篇博客用了不少不太懂怎么证明的东西，有不少事情都是直接引用结论，有需要都可以自行查找。

## 八数码的一票否决

如果我们把八数码拉成一条直线，比如23415768，能形成一个序列。对于一个序列，如果它都逆序对总数是奇数，我们就叫奇排列，偶数则为偶排列。在八数码问题中，通过移动方片都位置，无法让奇排列和偶排列互相转换。而由于最终状态12345678是偶排列，因此只需要判断输入序列的奇偶性，就可判断是否有解。这可以直接将unsolved问题用32次运算就计算出来。

```
int resPair(int *input = dig) {
    int resp = 0;
    for (int i = 0; i < 9; ++i) {
        for(int j = i + 1; j < 9; ++j) {
            if (input[i] == 9 || input[j] == 9 )
                continue;
            if (input[i] > input[j]) {
                ++resp;
            }
        }
    }
    return resp;
}

bool isChangeable() {
    int endOrder[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    int r1 = resPair(), r2 = resPair(endOrder);
    return r1 % 2 == r2 % 2;
}
```

## 快速求出第K字典序—康托展开/康托逆展开

康托展开是一种对序列的哈希方法，它会求出每一个排列的字典序次序。求出次序的做法，我们可以用next_permutation然后暴力判断，但这样很明显复杂度太高。我们采用比较的方法。

比如我们需要求序列684159732的字典序大小，我们得到的第一个信息就是第一位是`6`。那么我们假设序列为`6********`，它一定大于任何`1`到`5`开头的序列。如果确定了开头为`x`，那`x********`一共就有$8!$种，所以`6********`至少比$5*8!$个排列大。

接下来在枚举确定6以后都排列，排列为`68*******`，它大于任何前缀为`61`,`62`,`63`,`64`,`65`,`67`，即去掉前面已经枚举的6以外，所有剩下都排列。它一共大于![](http://latex.codecogs.com/svg.latex?5*8!%2B6*7!)个排列。

一直按照这样的算法算到底，它一共大于![](http://latex.codecogs.com/svg.latex?5*8!%2B6*7!%2B3*6!%2B2*4!%2B3*3!%2B2*2!%2B1*1!)个次序，这就是它的排列。

```cpp
int getIndex(int tile) {
    int res = 0;
    bool mem[10];
    memset(mem, false, sizeof mem);

    int t = 0, s[10];
    getArrayFromNum(tile, s);

    for (int i = 0; i < 9; i++) {
        int val = s[i];
        mem[val] = true;
        int cnt = 0;
        for (int j = 1; j < val; j++) {
            if (mem[j] == 0)
                cnt++;
        }
        res += cnt * factor[8 - i];
    }

    return res;
}
```

反过来也一样，我们看公式就知道，可以通过求商得出当前任何一个数字是什么。比如次序为![](http://latex.codecogs.com/svg.latex?s%3D5*8!%2B6*7!%2B3*6!%2B2*4!%2B3*3!%2B2*2!%2B1*1!)的排列。![](http://latex.codecogs.com/svg.latex?s%2F(8!)%3D5)，则知道第一位大于5个数，所以求出第一位是6。接着可以通过求余运算求出剩下的排列在`6********`下的次序，然后通过相同的方式就可全部接下来都数字，重复多次就可以求出所有的数字。

```cpp

bool mem[10];
int s[10];
memset(mem, false, sizeof mem);
for (int i = 8; i >= 0; --i) {
    int gt = index / factor[i];
    index %= factor[i];
    int pos;
    for(int j = 1; j <= 9; ++j) {
        if(mem[j] == 0) {
            pos = j;
            break;
        }
    }

    while(gt--) {
        pos++;
        while(mem[pos]) {
            pos++;
        }
    }

    mem[pos] = true;
    s[8-i] = pos;
}
```

## BFS求解八数码

用BFS求解其实就是把用八数码+哈希的方式求解。在实现代码时，可以用否决法把无用状态否决，接着一定有结果的BFS方式是这样：

```python
从队列弹出头结点状态：
    尝试把头结点的空白方片往四个方向移动:
        如果 [新状态合法 and 新状态没被访问过]:
            记录新状态为已访问
            将此新状态加入队列
    如果该状态为最终状态：
        结算经过的路线，退出程序
```

代码参考：
简单BFS https://paste.ubuntu.com/p/R56876c2K5/

## BFS搜索空间优化—双向搜索

如果我们同时从起点和终点开始搜索，可以大幅度节省状态的使用。一般上，搜索都深度和生成树的大小是指数性增加的。比如题目POJ1077的样例，最短一共要19步。1次19步都搜索深度远比2次10步都搜索量要大。将算法换成双向搜索的时候，时间花费从450ms大幅度优化到了32ms。已经加快了非常多了。

双向BFS的搜索方式如下：

```python
定义 顺序队列、逆序队列、中间节点
循环-任意队列非空：
    弹出顺序队列头结点
    获取周围四个节点:
        如果某个点没被经过:
            记录为已经过
            加入顺序队列
    
    弹出逆序队列头结点:
    获取周围四个点:
        如果某个点没被经过
            记录为经过
            加入逆序队列
    
    如果 [ 顺序队列的扩展节点曾出现在逆序队列中 or 逆序队列的扩展节点曾出现在顺序队列中 ]:
        将该扩展节点记录为中间节点
        在顺序队列状态中获取起点到中间节点的路线
        在逆序队列状态中获取终点到中间节点的路线

```

[双向BFS](https://i.loli.net/2019/09/25/jevyd2TPC7FX6GA.png)

代码参考：
双向BFS https://paste.ubuntu.com/p/Y59vd2pSmW/

## 曼哈顿启发式搜索—A* with manhattan

启发式搜索，它的主要逻辑是估算出全局路线最短的节点。每次都从那个节点开始扩展，每次都寻找期望的最短路径。在搜索问题中，均存在已知状态和未知状态两部分。![](http://latex.codecogs.com/svg.latex?A^*)的思想在于先求出已知节点到起点的距离，再估算该已知节点到终点的距离，到起点的距离是准确的，到终点的距离是要估算的。如果类比到Dijk最短路算法，它也是![](http://latex.codecogs.com/svg.latex?A^*)搜索的一种，它先计算出起点到中间点的距离，然后忽视未知的情况，然而这种贪心策略的正确性被证明。

八数码问题的估算策略采取曼哈顿距离的方式，对于其中的某一个状态，记录每个方片距离目标位置的曼哈顿距离之和。每次弹出的状态使得估算的最终状态最短。

```python
定义A*节点，g-起点到该点距离，h-估算该点到终点距离，f=g+h估算总路线长度
定义A*节点优先队列，每次弹出f最小的点，也就是估算总路径长度最小的点
定义 close表-已访问的节点（状态确定） open表-已访问节点的周边节点（状态未确定）
while 优先队列非空:
    弹出优先队列堆头节点
    如果已经在close表:
        continue

    加入close表
    if 找到终点:
        弹出经过的路径

    扩展周边四个节点:
        if 节点合法:
            计算已经过的距离
            估算到终点的距离
            if (节点未在open表 and 已经过的距离比原记录更短):
                更新open表
                将新节点加入优先队列
```

其中有个重点是估价函数，估价函数的好坏决定了整体性能的好坏。估价函数h(n)必须满足![](http://latex.codecogs.com/svg.latex?h(n)%3Cstep)，一定要比最终状态小。不然都没法近似地搜索出最终结果。

启发式搜索 https://paste.ubuntu.com/p/zvXTVsP8gw/

## 引用启发函数限制深度——IDA*迭代加深搜索

`IDA*`全名叫迭代加深![](http://latex.codecogs.com/svg.latex?A%5E*)搜索。我们可以用深度优先搜索法，加上![](http://latex.codecogs.com/svg.latex?f(n)%3Cstep)的深度剪枝。这个搜索一共分两部分，迭代加深和搜索。迭代加深指限制搜索层数，当深度超过一个范围值就退出。在八数码问题中，我们把深度从1开始往上加，直到加到能找到的深度。这样搜索得到的距离一定是最短的。

在八数码问题的应用中，我们用了![](http://latex.codecogs.com/svg.latex?A%5E*)搜索的思想。定义当前节点为n，当前深度为g(n)，用曼哈顿距离估算深度为h(n)，而`g(n)+h(n)=f(n)<depth`。那我们可以加上一条强力的剪枝，每次计算出f(n)，如果计算出估算深度比限制深度要大，则直接退出。

```python
迭代加深:
    最大深度=0
    for 最大深度++:
        if dfs(起点，最大深度):
            输出路径
            break;

dfs(n, 最大深度):
    g(n)=当前深度
    h(n)=估算深度
    if h(n) == 0:
        找到终点，返回路径
        return True

    计算f(n)=g(n)+h(n)
    if f(n) > 最大深度:
        return False
```

代码参考：
`IDA*`迭代加深搜索 https://paste.ubuntu.com/p/tMGVZk4zFs/
